(ns pluralsight.types)

;; everything is an expresion
;; statement = an action to be performed - does not return a value
;; expresion = a suntactic unit that can be evaluated - returns a value
;; in clojure everything is an expression included ifs
;; Parentheses define scope and structure around expressions, in clojure code is data
;; nil is returned from expressions that produces side effects

(defn make-name [first-name]
	(str first-name " Bennet"))

(make-name "Zachary")

(println (make-name "Zachary"))

(def my-number 1)

;; strings literals and numeric in clojure
;; strings are sequences of characters chained together
;; Character type is a single character like  A, B or C
;; Regular expressions is for parsing values in our string is for validation purpuses.

(def hello "hello world" )

(def z-char \z )

(def my-regexp #"[A-Z]" )

(print hello z-char my-regexp)

;; numeric types
;; integers = which correspond to whole numbrers, 
;; floating point values = decimal values for precition
;; ratios, correspond to numerator and denominator

(def hundred 100 )

(def my-floating-point 100.12345 )

(def my-ratio 10/7 )

;; a core, numeric function that returns the integer 10 the numerator of the given ration

(def numerator my-ratio )

(print hundred my-floating-point my-ratio)

;; collentions has two categories
;; sequential collections = order elements list and vectors are sequential collections
;; hashed collections = unordered collection of elements sets and maps

;; vectors have indexed elements. New elements are added to the end of the vector
(def my-vector [1 2 3] )
(get my-vector 0)


;; every code in clojure is data, so every statemante and functions is taken and a list
;; compiler takes in parses and evaluates, this bit of code here defines a list
;; list no provides index access, you have to walk over it on each element to find what you want
;; this backtick works sayint to clojure "don`t evaluate this list"
(def my-list '(1 2 3) )
(first my-list)


;; Hashed collections

;; sets are perfect for collection containing a big jumble of elements in which you want to be sure there are no duplicates
#{"Herman" "Orando" "Morales"}

(contains? #{"Herman" "Orlando"} "Herman")


;; A map is a series of key/value pairs enclosed by curly braces. Remember that commas are optional
;; as they are treated as whitespace!
;; these data structures are inmutables

{:herman 1 :orlando 2 :morales 3}

(assoc {:herman 1} :morales 2)

;; symbols and keywords
;; symbols are composed of letters, numbers, and other punctuation and are used to refer to 
;; something else, like a function. value, namespace, etc
;; symbols are just names!

;; in clojure the plus sign is a symbol that points to a function
(+ 1 2)

;; namespaces symbols
(clojure.core/+ 1 2)

;; special symbos in clojure wich actually refer to core types. These are
;; "nil" "true" "false"

nil
true
false

;; keyworks are like special symbols that always refer to themselves
;; they are used as string constants like atoms on elixir

:foobar

;; namespace keyworkd uses two semicolon
::foobar

; keyworks are used with maps
(def my-map {:zach 1 :kalie 2} )
(get my-map :kalie)
(:kalie my-map)

;; custom data types in clojure are modeled used the map

;; when comes to custom data types in clojure that do not involve map, there a many options
;; to choose from, but these are the most common options, deftype and defrecord are macros
;; deftype is mainly use to create programming abstractions, is a kind of like a lightwight defrecod, it generates a type with 
;; a simple constructor and that's basically it. it's great for creating types that, you want
;; really fine-grained control over. Defrecord create a new type with a ton of built-in functionalyto baked into it.
;; givin all the functionality to all map datatype both of these types should be used to implement abstractions and APIs
;; generated by something called clojure protocols

;; protoco is a named set of named methos and their signatures, defined using defprotocol, you can think of protocols as interfaces
;; a declaration of an API wich you can then implement. deftype and defrecord can be used to create types which implement a given protocol
;; this comes in handy with java interperability, the gist is when it come to creating custom data types in clojure
;; prefer simple maps, unless you're interacting with protocols, or if need java interoperability



;; defrecod generates an inmutable, persistent map. this generated type has all the capabilities of a built-in map.
(defrecord Person [name address])

;; deftype generates a new type with a contructor, the specified fils, and nothing else. you can also mutate fields in a 
;; object generated using deftype

(deftype Position [x y] )
